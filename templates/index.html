<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Diagnostic & Optimisation</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
       /* styles.css */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

:root {
    --couleur-primaire: #66a5ad; /* Bleu-vert doux */
    --couleur-secondaire: #86acaa; /* Vert d'eau */
    --couleur-accent: #f4a261; /* Orange chaud */
    --couleur-fond: #f8f9fa; /* Gris très clair */
    --couleur-texte: #495057; /* Gris foncé */
    --police-famille: 'Roboto', Arial, sans-serif;
}

body {
    font-family: var(--police-famille);
    background-color: var(--couleur-fond);
    color: var(--couleur-texte);
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    transition: background-color 0.3s ease;
}

h1 {
    text-align: center;
    color: var(--couleur-primaire);
    margin-top: 2rem;
    animation: fadeInDown 0.8s ease-out;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
}

form {
    max-width: 700px;
    margin: 30px auto;
    padding: 30px;
    background-color: #fff;
    border-radius: 15px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    animation: fadeInUp 0.8s ease-out;
}

form:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 25px rgba(0, 0, 0, 0.2);
}

form div {
    margin-bottom: 20px;
}

label {
    display: block;
    font-weight: 500;
    margin-bottom: 8px;
    color: #555;
    transition: color 0.3s ease;
}

input[type="file"],
input[type="number"],
select {
    width: calc(100% - 16px);
    padding: 12px;
    margin-top: 8px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 8px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

input[type="file"]:focus,
input[type="number"]:focus,
select:focus {
    outline: none;
    border-color: var(--couleur-primaire);
    box-shadow: 0 0 5px rgba(102, 165, 173, 0.5); /* Couleur primaire en rgba */
}

button {
    width: 100%;
    padding: 14px;
    font-size: 18px;
    background: linear-gradient(to right, var(--couleur-primaire), var(--couleur-secondaire));
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    font-weight: 500;
}

button:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

#errorMessages {
    color: #dc3545;
    list-style-type: none;
    padding: 0;
    margin-top: 10px;
    animation: shake 0.5s ease-in-out;
}

#result, #optimizedResult {
    max-width: 100%; /* Ajustez la largeur maximale */
    margin: 40px auto;
    padding: 30px;
    background-color: #fff;
    border-radius: 15px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    animation: fadeIn 0.8s ease-out;
    overflow-x: auto; /* Ajoute un défilement horizontal si nécessaire */
}

#result h2, #optimizedResult h2 {
    color: var(--couleur-primaire);
    text-align: center;
    margin-bottom: 25px;
    font-weight: 600;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 30px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    border-radius: 10px;
    overflow: hidden;
    min-width: 800px; /* Largeur minimale pour éviter le débordement */
}

th, td {
    padding: 12px; /* Réduire le padding pour gagner de l'espace */
    text-align: left;
    border-bottom: 1px solid #eee;
}

th {
    background-color: var(--couleur-primaire);
    color: white;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

tbody tr:nth-child(even) {
    background-color: #f9f9f9;
}

tbody tr:hover {
    background-color: #f2f2f2;
    transition: background-color 0.2s ease;
}

.diagnostic-suroffre {
    background-color: #d4edda;
    color: #155724;
    padding: 5px 10px;
    border-radius: 5px;
}

.diagnostic-sousoffre {
    background-color: #f8d7da;
    color: #721c24;
    padding: 5px 10px;
    border-radius: 5px;
}

.header-actions {
    display: flex;
    justify-content: flex-end;
    padding: 20px;
    background-color: #f8f9fa;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

table#optimizedTable {
    border: 1px solid #ddd;
    border-radius: 10px;
    overflow: hidden;
    font-size: 15px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
    background-color: #f8f9fa;
    animation: fadeIn 0.8s ease-out;
    min-width: 1000px; /* Largeur minimale pour éviter le débordement */
}

table#optimizedTable thead {
    background-color: var(--couleur-primaire);
    color: white;
    text-transform: uppercase;
}

table#optimizedTable th {
    padding: 12px; /* Réduire le padding pour gagner de l'espace */
    text-align: left;
    font-weight: 500;
}

table#optimizedTable tbody tr:nth-child(odd) {
    background-color: #e9ecef;
}

table#optimizedTable tbody tr:nth-child(even) {
    background-color: white;
}

table#optimizedTable tbody tr:hover {
    background-color: #f1f3f5;
    transition: background-color 0.2s ease;
}

table#optimizedTable td {
    padding: 12px; /* Réduire le padding pour gagner de l'espace */
    border-bottom: 1px solid #ddd;
}

table#optimizedTable td:nth-child(5),
table#optimizedTable td:nth-child(6),
table#optimizedTable td:nth-child(7),
table#optimizedTable td:nth-child(8) {
    text-align: center;
}

table#optimizedTable td.freq-opti {
    font-weight: 600;
}

table#optimizedTable td.charge-opti {
    font-weight: 600;
}

table#optimizedTable td:empty::before {
    content: "—";
    font-style: italic;
    color: #888;
}

.indicators {
    display: flex;
    justify-content: space-between;
    padding: 30px;
    margin-bottom: 30px;
}

.indicator-group {
    width: 45%;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

.indicator {
    background-color: #fff;
    border: 2px solid #ddd;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    padding: 20px;
    text-align: center;
    color: #333;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.indicator:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
}

.indicator h3 {
    font-size: 18px;
    margin: 0;
    color: var(--couleur-primaire);
    font-weight: 600;
}

.indicator p {
    font-size: 24px;
    margin: 12px 0 0;
    font-weight: bold;
    color: #333;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes fadeInDown {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes shake {
    0% {
        transform: translateX(0);
    }
    25% {
        transform: translateX(-5px);
    }
    50% {
        transform: translateX(5px);
    }
    75% {
        transform: translateX(-5px);
    }
    100% {
        transform: translateX(0);
    }
}

.export-button {
    padding: 10px 15px;
    font-size: 14px;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    transition: background-color 0.2s ease;
}

.export-button:hover {
    background-color: #218838;
}

th input {
    width: 90%;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    margin: 0;
    box-sizing: border-box;
}

/* Style pour le bouton Optimisation */
#optimizerButton {
    background: linear-gradient(to right, var(--couleur-primaire), var(--couleur-secondaire));
    color: white; /* Texte en blanc */
    border: none;
    border-radius: 8px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    font-weight: 500;
    margin-left: 10px; /* Ajoute une marge à gauche pour l'espacement */
}

#optimizerButton:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#optimizerButton:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* Style pour le bouton Diagnostic */
#diagnosticButton {
    background: linear-gradient(to right, var(--couleur-primaire), var(--couleur-secondaire));
    color: white; /* Texte en blanc */
    border: none;
    border-radius: 8px;
    padding: 14px;
    font-size: 18px;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    font-weight: 500;
}

#diagnosticButton:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#diagnosticButton:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* Style pour le conteneur des boutons */
.header-actions {
    display: flex;
    justify-content: flex-end;
    padding: 20px;
    background-color: var(--couleur-fond); /* Utilise la couleur de fond du thème */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.diagnostic-ok {
    background-color: #d1ecf1;
    color: #0c5460;
    padding: 5px 10px;
    border-radius: 5px;
}
/* Style pour la barre de navigation */
nav {
    background-color: #ffffff; /* Fond blanc */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre légère */
    padding: 10px 20px;
    position: sticky;
    top: 0;
    z-index: 1000;
}

nav ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
    display: flex;
    justify-content: center;
    gap: 20px; /* Espace entre les boutons */
}

nav ul li {
    margin: 0;
}

nav ul li a {
    text-decoration: none;
    color: #28a745; /* Texte vert */
    background-color: transparent;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    transition: all 0.3s ease;
    border: 2px solid #28a745; /* Bordure verte */
}

nav ul li a:hover {
    background-color: #28a745; /* Fond vert au survol */
    color: white; /* Texte blanc au survol */
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

nav ul li a:active {
    transform: translateY(0);
    box-shadow: none;
}


    #filterModal {
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        width: 300px;
        max-height: 80vh; /* Limite la hauteur à 80% de la hauteur de l'écran */
        overflow-y: auto; /* Ajoute une barre de défilement si nécessaire */
        text-align: center;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
    }

    #filterModal h3 {
        margin-top: 0;
    }

    #filterModal label {
        display: block;
        margin: 10px 0;
    }

    #filterModal button {
        margin: 10px 5px;
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
        background-color: #66a5ad;
        color: white;
        cursor: pointer;
    }

    #filterModal button:hover {
        background-color: #5599a1;
    }

    #filterOptions {
        max-height: 60vh; /* Limite la hauteur des options de filtre */
        overflow-y: auto; /* Ajoute une barre de défilement si nécessaire */
        margin-bottom: 20px; /* Espace avant les boutons */
    }
.nb-rames-exist {
    font-weight: 500; /* Exemple de style */
    text-align: center; /* Centrer le texte */
}
.nb-rames-opti {
    font-weight: 500; /* Exemple de style */
    text-align: center; /* Centrer le texte */
}
table#optimizedTable {
    font-family: Arial, sans-serif; /* Utiliser une police plus compacte */
    font-size: 12px; /* Réduire la taille de la police */
}
table#diagnosticTable {
    font-family: Arial, sans-serif; /* Utiliser la même police que le tableau optimisé */
    font-size: 14px; /* Utiliser la même taille de police que le tableau optimisé */
}
/* Style simple et élégant pour les boutons de navigation */
nav {
    background-color: #ffffff; /* Fond blanc */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Ombre légère */
    padding: 10px 20px;
    position: sticky;
    top: 0;
    z-index: 1000;
}

nav ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
    display: flex;
    justify-content: center;
    gap: 15px; /* Espace entre les boutons */
}

nav ul li {
    margin: 0;
}

nav ul li a {
    text-decoration: none;
    color: var(--couleur-primaire); /* Utilise la couleur primaire de l'appli */
    background-color: transparent; /* Fond transparent */
    padding: 10px 20px;
    border-radius: 8px; /* Coins arrondis */
    font-size: 16px;
    font-weight: 500;
    transition: all 0.3s ease;
    border: 2px solid var(--couleur-primaire); /* Bordure avec la couleur primaire */
}

nav ul li a:hover {
    background-color: var(--couleur-primaire); /* Fond avec la couleur primaire au survol */
    color: white; /* Texte blanc au survol */
    transform: translateY(-2px); /* Léger effet de soulèvement */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Ombre au survol */
}

nav ul li a:active {
    transform: translateY(0); /* Retour à la position initiale au clic */
    box-shadow: none; /* Supprime l'ombre au clic */
}

/* Style pour les écrans plus petits */
@media (max-width: 768px) {
    nav ul {
        flex-direction: column; /* Empile les boutons verticalement */
        gap: 10px; /* Réduit l'espace entre les boutons */
    }

    nav ul li a {
        padding: 8px 15px; /* Réduit le padding sur mobile */
        font-size: 14px; /* Réduit la taille de la police */
    }
}
/* Style pour le texte défilant */
.scrolling-text {
    position: fixed;
    top: 50%; /* Centrer verticalement */
    left: 0;
    right: 0;
    white-space: nowrap; /* Empêcher le texte de se diviser en plusieurs lignes */
    overflow: hidden; /* Cacher le texte qui dépasse */
    color: rgba(102, 165, 173, 0.3); /* Couleur du texte (bleu-vert clair) */
    font-size: 3rem; /* Taille du texte */
    font-weight: bold; /* Texte en gras */
    z-index: -1; /* Placer en arrière-plan */
    animation: scrollText 20s linear infinite; /* Animation de défilement */
}

/* Animation pour faire défiler le texte */
@keyframes scrollText {
    from {
        transform: translateX(100%); /* Commencer à droite */
    }
    to {
        transform: translateX(-100%); /* Finir à gauche */
    }
}
@media print {
    table {
        width: 100% !important;
        font-size: 12px !important;
    }
    th, td {
        padding: 8px !important;
    }
}




    </style>
</head>
<body>
<!-- Logo en haut à droite
<div class="logo-container">
    <img src="images/test.png" alt="Logo KEO Appli" class="logo-image">
</div>-->

<!-- Texte défilant en arrière-plan -->
    <div class="scrolling-text">
        Bienvenue sur la ligne B, là où l'offre est magique !
    </div>
    <nav>
    <ul>
        <li><a href="#result">Diagnostic</a></li>
        <li><a href="#optimizedResult">Optimisation</a></li>
        <li><a href="#chartContainer">Graphique</a></li>
    </ul>
</nav>


    <h1>Diagnostic et Optimisation - Ligne b</h1>
    <form id="uploadForm" method="POST" enctype="multipart/form-data">
        <div>
            <label for="firstFile"> Fichier Excel offre aux 5 minutes:</label>
            <input type="file" name="firstFile" id="firstFile" required>
        </div>

        <div id="selectSheet" class="hidden">
            <label for="sheet">Choisissez la période d'analyse:</label>
            <select name="sheet" id="sheet"></select>
        </div>

        <div id="secondFileDiv" class="hidden">
            <label for="secondFile">Fichier de fréquentation sens aller (Saint-Jacques – Gaîté -> Cesson – Viasilva):</label>
            <input type="file" name="secondFile" id="secondFile">
        </div>

        <div id="thirdFileDiv" class="hidden">
            <label for="thirdFile">Fichier de fréquentation sens retour (Cesson – Viasilva -> Saint-Jacques – Gaîté  ):</label>
            <input type="file" name="thirdFile" id="thirdFile">
        </div>

        <div>
            <label for="peakCapacity">Seuil maximal aux Heures de Pointe JOB(7h–9h, 12h–13h(Mercredi-Oct) et 16h–18h30):</label>
            <input type="number" id="peakCapacity" value="168">
        </div>


        <div>
            <label for="offPeakCapacity">Seuil maximal aux Heures Creuses:</label>
            <input type="number" id="offPeakCapacity" value="110">
        </div>

        <div>
            <label for="coefHeures">Coefficient Heures (%):</label>
            <input type="number" id="coefHeures" value="90" min="0" max="100" required>
        </div>
        <div>
    <label for="coefHeuresSup">Coefficient Heures Supérieur (%):</label>
    <input type="number" id="coefHeuresSup" value="5" min="0" max="100" required>
</div>



        <button type="button" id="diagnosticButton">Diagnostic</button>
    </form>
    <ul id="errorMessages"></ul>

    <div id="result" class="hidden">
        <h2>Résultats du Diagnostic</h2>
        <table id="diagnosticTable">
    <thead>
        <tr>
            <th>Tranche Horaire</th>
            <th>Tranches Offre</th>
            <th>Max Voyageurs</th>
            <th>Nb Rames Existante</th>
            <th>Fréquence Existante</th>
            <th>Diagnostic</th>
        </tr>
        <tr id="diagnosticFilters">
            <!-- Ajoutez des champs de saisie pour chaque colonne -->
            <th><input type="text" placeholder="Filtrer Tranche Horaire" oninput="filterTable('diagnosticTable', 0)"></th>
            <th><input type="text" placeholder="Filtrer Tranches Offre" oninput="filterTable('diagnosticTable', 1)"></th>
            <th><input type="text" placeholder="Filtrer Max Voyageurs" oninput="filterTable('diagnosticTable', 2)"></th>
            <th><input type="text" placeholder="Filtrer Nb Rames" oninput="filterTable('diagnosticTable', 3)"></th>
            <th><input type="text" placeholder="Filtrer Fréquence" oninput="filterTable('diagnosticTable', 4)"></th>
            <th><input type="text" placeholder="Filtrer Diagnostic" oninput="filterTable('diagnosticTable', 5)"></th>
        </tr>
    </thead>
    <tbody></tbody>
</table>
<button onclick="resetFilters('diagnosticTable')">Réinitialiser les filtres</button>



         <button class="export-button" onclick="exportTableToExcel('diagnosticTable', 'Diagnostic_Results')">Exporter vers Excel</button>
        <button class="export-button" onclick="exportTableToPDF('diagnosticTable', 'Diagnostic_Results')">Exporter vers PDF</button>

    </div>


    <div id="optimizedResult" class="hidden">
        <h2>Résultats de l'Optimisation</h2>
         <button id="optimizerButton">Optimisation</button>
        <table id="optimizedTable">
    <thead>
        <tr>
            <th>Direction</th>
            <th>Tranche Horaire</th>
            <th>Tranches Offre</th>
            <th>Charge Existante</th>
            <th>Fréquence Existante</th>
             <th>Nb Rames Existante</th> <!-- Nouvelle colonne -->
            <th>Diagnostic avant optimisation</th>
            <th>Fréquence Optimisée</th>
            <th>Nb Rames Optimisée</th> <!-- Nouvelle colonne -->
            <th>Charge Optimisée</th>
            <th>Diagnostic après optimisation</th>
        </tr>
        <tr id="optimizedFilters">
            <!-- Ajoutez des champs de saisie pour chaque colonne -->
            <th><input type="text" placeholder="Filtrer Direction" oninput="filterTable('optimizedTable', 0)"></th>
            <th><input type="text" placeholder="Filtrer Tranche Horaire" oninput="filterTable('optimizedTable', 1)"></th>
            <th><input type="text" placeholder="Filtrer Tranches Offre" oninput="filterTable('optimizedTable', 2)"></th>
            <th><input type="text" placeholder="Filtrer Charge Existante" oninput="filterTable('optimizedTable', 3)"></th>
            <th><input type="text" placeholder="Filtrer Fréquence Existante" oninput="filterTable('optimizedTable', 4)"></th>
            <th><input type="text" placeholder="Filtrer Nb Rames" oninput="filterTable('optimizedTable', 5)"></th>
            <th><input type="text" placeholder="Filtrer Diagnostic avant optimisation" oninput="filterTable('optimizedTable', 6)"></th>
            <th><input type="text" placeholder="Filtrer Fréquence Optimisée" oninput="filterTable('optimizedTable', 7)"></th>
            <th><input type="text" placeholder="Filtrer Nb Rames Optimisée" oninput="filterTable('optimizedTable', 8)"></th> <!-- Nouveau filtre -->
            <th><input type="text" placeholder="Filtrer Charge Optimisée" oninput="filterTable('optimizedTable', 9)"></th>
            <th><input type="text" placeholder="Filtrer Diagnostic" oninput="filterTable('optimizedTable', 10)"></th>
        </tr>

    </thead>

    <tbody></tbody>

</table>
        <button onclick="resetFilters('optimizedTable')">Réinitialiser les filtres</button>
        <label for="directionSelect">Choisir la direction :</label>
        <select id="directionSelect">
            <option value="CVI_SJG">CVI → SJG</option>
            <option value="SJG_CVI">SJG → CVI</option>
        </select>
        <button id="graphButton" class="export-button">Afficher le Graphique</button> <!-- Nouveau bouton -->
        <div id="chartContainer"></div> <!-- Conteneur pour le graphique interactif -->
        <button class="export-button" onclick="exportTableToExcel('optimizedTable', 'Optimisation_Results')">Exporter vers Excel</button>
        <button class="export-button" onclick="exportTableToPDF('optimizedTable', 'Optimisation_Results')">Exporter vers PDF</button>
    </div>

<!-- Boîte modale pour le filtre -->
<div id="filterModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); z-index: 1000;">
    <h3>Filtrer la colonne</h3>
    <div>
        <label>
            <input type="checkbox" id="selectAll"> Sélectionner tout
        </label>
    </div>
    <div id="filterOptions" style="max-height: 200px; overflow-y: auto; margin-bottom: 20px;"></div>
    <div>
        <button id="applyFilterButton">OK</button>
        <button id="cancelFilterButton">Annuler</button>
    </div>
</div>

    <script>
        /* script.js */
        document.addEventListener('DOMContentLoaded', () => {
            // Ajout des écouteurs d'événements
            document.getElementById('firstFile').addEventListener('change', handleFirstFileChange);
            document.getElementById('diagnosticButton').addEventListener('click', processFiles);
            document.getElementById('optimizerButton').addEventListener('click', optimizeData);
            // Ajouter un écouteur pour le bouton "Graphique"
    document.getElementById('graphButton').addEventListener('click', () => {
    const data = extractDataForChart();
    const selectedPeriod = document.getElementById('sheet').value;
    const chartTitle = `Visualisation de la charge et du nombre de rames - ${selectedPeriod}`;

    // Créer les données pour le graphique
    const chartData = [
        // Aire pour le nombre de rames existantes
        {
            x: data.map(item => item.trancheHoraire),
            y: data.map(item => item.nbRamesExistante),
            name: 'Nb Rames Existantes',
            type: 'scatter',
            mode: 'lines',
            fill: 'tozeroy',
            line: { color: 'rgba(128, 0, 128, 0.5)', width: 0 }, // Violet transparent
            fillcolor: 'rgba(128, 0, 128, 0.2)',
            yaxis: 'y2'
        },
        // Aire pour le nombre de rames optimisées
        {
            x: data.map(item => item.trancheHoraire),
            y: data.map(item => item.nbRamesOptimisee),
            name: 'Nb Rames Optimisées',
            type: 'scatter',
            mode: 'lines',
            fill: 'tozeroy',
            line: { color: 'rgba(255, 165, 0, 0.5)', width: 0 }, // Orange transparent
            fillcolor: 'rgba(255, 165, 0, 0.2)',
            yaxis: 'y2'
        },
        // Courbe pour la charge existante
        {
            x: data.map(item => item.trancheHoraire),
            y: data.map(item => item.chargeExistante),
            name: 'Charge Existante',
            type: 'scatter',
            mode: 'lines',
            line: { color: 'blue', width: 2 },
            yaxis: 'y1'
        },
        // Courbe pour la charge optimisée
        {
            x: data.map(item => item.trancheHoraire),
            y: data.map(item => item.chargeOptimisee),
            name: 'Charge Optimisée',
            type: 'scatter',
            mode: 'lines',
            line: { color: 'green', width: 2 },
            yaxis: 'y1'
        }
    ];

    // Définir la mise en page du graphique
    const layout = {
        title: chartTitle,
        xaxis: { title: 'Tranche Horaire' },
        yaxis: {
            title: 'Charge',
            titlefont: { color: 'blue' },
            tickfont: { color: 'blue' }
        },
        yaxis2: {
            title: 'Nombre de rames',
            titlefont: { color: 'purple' },
            tickfont: { color: 'purple' },
            overlaying: 'y',
            side: 'right'
        },
        legend: {
            x: 0.5,
            y: 1.05,
            orientation: 'h',
            xanchor: 'center',
            yanchor: 'bottom'
        },
        margin: { t: 80 }
    };

    // Afficher le graphique
    Plotly.newPlot('chartContainer', chartData, layout);
});














            // Fonction pour gérer le changement du premier fichier
            async function handleFirstFileChange() {
                const fileInput = document.getElementById('firstFile');
                const formData = new FormData();
                formData.append('firstFile', fileInput.files[0]);

                try {
                    const data = await uploadFile('/upload_first_file', formData);
                    if (data && data.sheet_names) {
                        populateSheetOptions(data.sheet_names);
                        showFileDivs();
                    } else {
                        console.error("Réponse du serveur invalide :", data);
                        displayErrorMessage("Réponse du serveur invalide. Veuillez réessayer.");
                    }
                } catch (error) {
                    displayErrorMessage(`Erreur lors du chargement du fichier : ${error.message}`);
                }
            }

            // Fonction pour remplir les options de la feuille
            function populateSheetOptions(sheetNames) {
                const sheetSelect = document.getElementById('sheet');
                sheetSelect.innerHTML = '';
                sheetNames.forEach(sheet => {
                    const option = document.createElement('option');
                    option.value = sheet;
                    option.textContent = sheet;
                    sheetSelect.add(option);
                });
            }

            // Fonction pour afficher les divs des fichiers
            function showFileDivs() {
                document.getElementById('selectSheet').classList.remove('hidden');
                document.getElementById('secondFileDiv').classList.remove('hidden');
                document.getElementById('thirdFileDiv').classList.remove('hidden');
            }

            // Fonction principale pour traiter les fichiers
            async function processFiles() {
                const form = document.getElementById('uploadForm');
                const formData = new FormData(form);

                try {
                    const data = await uploadFiles('/process_files', formData);
                    if (data.error) {
                        displayErrorMessage(data.error);
                    } else {
                        createDiagnosticTable(data);
                        showResult();
                    }
                } catch (error) {
                    displayErrorMessage(`Erreur lors du traitement des fichiers : ${error.message}`);
                }
            }

            // Fonction pour créer le tableau de diagnostic
           function createDiagnosticTable(data) {
    const table = document.getElementById('diagnosticTable');
    const tbody = table.querySelector('tbody');
    tbody.innerHTML = '';

    function addDiagnosticRows(diagnosticData, direction) {
        if (diagnosticData) {
            const titleRow = tbody.insertRow();
            const titleCell = titleRow.insertCell(0);
            titleCell.colSpan = 6;
            titleCell.innerText = direction === "Sens Aller"
                ? `Diagnostics ${direction} (Gaité vers Cesson via Silva)`
                : `Diagnostics ${direction} (Cesson via Silva vers Gaité)`;
            titleCell.style.fontWeight = 'bold';

            const headerRow = tbody.insertRow();
            ['Tranche Horaire', 'Tranches Offre', 'Max Voyageurs', 'Nb Rames Existante', 'Fréquence Existante', 'Diagnostic'].forEach(text => {
                const th = document.createElement('th');
                th.innerText = text;
                headerRow.appendChild(th);
            });

            diagnosticData.forEach(diagnostic => {
                const row = tbody.insertRow();
                const diagnosis = getDiagnosis(parseInt(diagnostic.max_voyageurs, 10), diagnostic.tranche);

                // Ajouter les cellules
                const trancheCell = row.insertCell(0);
                trancheCell.innerText = diagnostic.tranche || 'N/A';

                const tranchesOffreCell = row.insertCell(1);
                tranchesOffreCell.innerText = diagnostic.tranches_offre || 'N/A';

                const maxVoyageursCell = row.insertCell(2);
                maxVoyageursCell.innerText = Math.round(parseFloat(diagnostic.max_voyageurs)); // Arrondir Max Voyageurs

                const nbRamesCell = row.insertCell(3);
                const nbRamesValue = parseFloat(diagnostic.nb_rames) || 0; // Un seul chiffre après la virgule
                nbRamesCell.innerText = nbRamesValue.toFixed(1); // Force le format à 1 décimale
                nbRamesCell.classList.add('nb-rames-exist');

                const frequenceCell = row.insertCell(4);
                frequenceCell.innerText = diagnostic.frequence || 'N/A';

                const diagnosisCell = row.insertCell(5);
                diagnosisCell.innerText = diagnosis;
                diagnosisCell.className = getDiagnosticClass(diagnosis);
                row.dataset.direction = direction;
            });
        }
    }

    addDiagnosticRows(data.diagnostic_sens_aller, "Sens Aller");
    addDiagnosticRows(data.diagnostic_sens_retour, "Sens Retour");
}





            // Fonction pour optimiser les données
           async function optimizeData() {
    const diagnosticTable = document.getElementById('diagnosticTable');
    const optimizedTable = document.getElementById('optimizedTable');

    if (!diagnosticTable || !optimizedTable) {
        displayErrorMessage("Tableaux de diagnostic ou d'optimisation introuvables.");
        return;
    }

    const diagnosticRows = Array.from(diagnosticTable.querySelectorAll("tbody tr"));
    if (diagnosticRows.length === 0) {
        displayErrorMessage("Le tableau de diagnostic est vide.");
        return;
    }

    // Filtrer les lignes "Sur-offre"
    const surOffreRows = diagnosticRows.filter(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length < 6) return false; // Ignorer les lignes invalides
        const diagnostic = cells[5].textContent.trim();
        return diagnostic === "Sur-offre" || diagnostic === "Sous-offre"; // Inclure "Sur-offre" et "Sous-offre"
    });

    const surOffreData = extractAndOptimizeData(surOffreRows);

    // Afficher le tableau optimisé
    populateOptimizedTable(surOffreData);
    showOptimizedResult(); // Affiche la section des résultats optimisés

    // Afficher un message et faire défiler vers le tableau optimisé
    const optimizedTableBody = document.getElementById('optimizedTable').querySelector("tbody");
    if (optimizedTableBody.rows.length === 0) {
        alert("Aucune ligne avec 'Sur-offre' n'a été trouvée.");
    } else {
        alert(`Nombre de lignes optimisées : ${optimizedTableBody.rows.length}`);
        document.getElementById('optimizedResult').scrollIntoView({ behavior: 'smooth' }); // Faire défiler
    }

    // Créer le graphique après l'affichage du tableau
    createOptimizationChart(surOffreData);
}

function isWeekendPeriod() {
    const selectedSheet = document.getElementById('sheet').value.toLowerCase();
    return selectedSheet.includes('samedi') || selectedSheet.includes('dimanche');
}




            // Fonction pour extraire et optimiser les données
           function extractAndOptimizeData(diagnosticRows) {
    const peakCapacity = parseInt(document.getElementById('peakCapacity').value, 10);
    const offPeakCapacity = parseInt(document.getElementById('offPeakCapacity').value, 10);
    const coefHeures = parseInt(document.getElementById('coefHeures').value, 10) / 100; // Borne inférieure
    const coefHeuresSup = parseInt(document.getElementById('coefHeuresSup').value, 10) / 100; // Borne supérieure

   const timeRanges = {
    peak: [['07:00', '09:00'], ['12:00', '13:00'], ['16:00', '18:30']], // Ajout de 12h-13h
    offPeak: [['00:00', '07:00'], ['09:00', '12:00'], ['13:00', '16:00'], ['18:30', '23:59']]
};


    // Fréquences disponibles (en hh:mm:ss)
    const peakFrequencies = [
        "00:01:37", "00:01:40", "00:01:44", "00:01:49", "00:01:54", "00:01:58", "00:02:05",
        "00:02:09", "00:02:15", "00:02:20", "00:02:22", "00:02:25", "00:02:32", "00:02:40", "00:02:50", "00:03:00"
    ];
    const offPeakFrequencies = [
        "00:02:05", "00:02:09", "00:02:15", "00:02:20", "00:02:22", "00:02:25", "00:02:32", "00:02:40", "00:02:50", "00:03:00", "00:03:12",
        "00:03:26", "00:03:42", "00:04:00", "00:04:15", "00:04:42", "00:05:20", "00:05:55"
    ];

    function isInRange(time, ranges) {
        for (let range of ranges) {
            if (time >= range[0] && time <= range[1]) {
                return true;
            }
        }
        return false;
    }

   function findBestFrequency(chargeExistante, frequenceExistanteMinutes, capaciteMax, availableFrequencies, trancheHoraire) {
    let bestFrequency = null;
    let bestCharge = chargeExistante;
    let minDifferenceToSeuil = Infinity; // Différence minimale par rapport au seuil (capaciteMax)
    let foundInTargetZone = false;

    const borneInf = capaciteMax * coefHeures;
    const borneSup = capaciteMax * (1 + coefHeuresSup);

    // Conversion pour vérification plage horaire
    const heure = trancheHoraire.substring(0, 8);
    const [h, m, s] = heure.split(':').map(Number);
    const heureDec = h + m/60 + s/3600;
    const isNightTime = heureDec >= 20.5 || heureDec <= 9;

    availableFrequencies.forEach(frequency => {
        // Exclusion de 00:05:55 en dehors des heures nocturnes
        if (frequency === "00:05:55" && !isNightTime) return;

        const [hFreq, mFreq, sFreq] = frequency.split(':').map(Number);
        const freqMinutes = hFreq * 60 + mFreq + sFreq/60;
        const chargeOptimisee = (chargeExistante * freqMinutes) / frequenceExistanteMinutes;
        const differenceToSeuil = Math.abs(chargeOptimisee - capaciteMax);

        // Critère principal : dans l'intervalle cible
        const isInTargetZone = chargeOptimisee >= borneInf && chargeOptimisee <= borneSup;

        // Si on trouve une fréquence dans la zone cible
        if (isInTargetZone) {
            foundInTargetZone = true;

            // On prend celle qui se rapproche le plus du seuil (capaciteMax)
            if (differenceToSeuil < minDifferenceToSeuil) {
                minDifferenceToSeuil = differenceToSeuil;
                bestFrequency = frequency;
                bestCharge = chargeOptimisee;
            }
        }

        // Si aucune fréquence n'est dans la zone cible, on prend la plus proche du seuil
        if (!foundInTargetZone && differenceToSeuil < minDifferenceToSeuil) {
            minDifferenceToSeuil = differenceToSeuil;
            bestFrequency = frequency;
            bestCharge = chargeOptimisee;
        }
    });

    return {
        bestFrequency: bestFrequency,
        bestCharge: bestCharge,
        isInTargetZone: foundInTargetZone
    };
}

 const allFrequencies = [
        "00:01:37", "00:01:40", "00:01:44", "00:01:49", "00:01:54", "00:01:58", "00:02:05",
        "00:02:09", "00:02:15", "00:02:20", "00:02:22", "00:02:25", "00:02:32", "00:02:40",
        "00:02:50", "00:03:00", "00:03:12", "00:03:26", "00:03:42", "00:04:00", "00:04:15",
        "00:04:42", "00:05:20", "00:05:55"
    ];


    return diagnosticRows.map(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length < 6) return null; // Ignorer les lignes invalides

        const direction = row.dataset.direction;
        const trancheHoraire = cells[0].textContent.trim();
        const tranchesOffre = cells[1].textContent.trim();
        const maxVoyageurs = parseInt(cells[2].textContent.trim(), 10);
        const nbRamesExistante = parseFloat(cells[3].textContent.trim().replace(',', '.')) || 0; // Récupérer le nombre de rames existantes
        const frequenceExistanteStr = cells[4].textContent.trim();
        const diagnosticAvantOptimisation = cells[5].textContent.trim(); // Récupérer le diagnostic

        // Vérifier que la fréquence existante et la charge existante sont valides
        if (!frequenceExistanteStr || frequenceExistanteStr === "0" || maxVoyageurs <= 0) {
            return {
                direction,
                trancheHoraire,
                tranchesOffre,
                chargeExistante: maxVoyageurs,
                frequenceExistante: frequenceExistanteStr,
                frequenceOptimisee: frequenceExistanteStr, // Utiliser la fréquence existante comme valeur par défaut
                chargeOptimisee: maxVoyageurs, // Utiliser la charge existante comme valeur par défaut
                diagnostic: 'N/A'
            };
        }

        const frequenceExistanteMinutes = convertTimeToMinutes(frequenceExistanteStr);
        if (frequenceExistanteMinutes === 0) {
            return {
                direction,
                trancheHoraire,
                tranchesOffre,
                chargeExistante: maxVoyageurs,
                frequenceExistante: frequenceExistanteStr,
                frequenceOptimisee: frequenceExistanteStr, // Utiliser la fréquence existante comme valeur par défaut
                chargeOptimisee: maxVoyageurs, // Utiliser la charge existante comme valeur par défaut
                diagnostic: 'N/A'
            };
        }

        const diagnosticTime = trancheHoraire.substring(0, 5);
        const capaciteMax = isInRange(diagnosticTime, timeRanges.peak) ? peakCapacity : offPeakCapacity;


        // Déterminer les fréquences disponibles
        let availableFrequencies;
        if (isWeekendPeriod()) {
            // Si c'est un weekend, on utilise toutes les fréquences sans distinction
            availableFrequencies = allFrequencies;
        } else {
            // Sinon, on utilise les fréquences selon peak/off-peak
            availableFrequencies = isInRange(diagnosticTime, timeRanges.peak) ? peakFrequencies : offPeakFrequencies;
        }


        // Trouver la meilleure fréquence pour rapprocher la charge optimisée du seuil
        const { bestFrequency, bestCharge } = findBestFrequency(
    maxVoyageurs,
    frequenceExistanteMinutes,
    capaciteMax,
    availableFrequencies,
    trancheHoraire // Bien passer la tranche horaire complète
);



        // Déterminer le diagnostic après optimisation
        const lowerBound = capaciteMax * coefHeures;
        const upperBound = capaciteMax * (1 + coefHeuresSup);
        let diagnostic;

         // Utiliser une tolérance de 0.5 pour inclure 98.5
        const tolerance = 0.5;

        if (bestCharge >= lowerBound - tolerance && bestCharge <= upperBound + tolerance) {
            diagnostic = 'OK'; // Charge optimisée dans la plage acceptable
        } else if (bestCharge > upperBound) {
            diagnostic = 'Sous-offre'; // Charge optimisée dépasse la borne supérieure
        } else {
            diagnostic = 'Sur-offre'; // Charge optimisée est en dessous de la borne inférieure
        }

        // Calculer le nombre de rames optimisées
    const frequenceOptimiseeMinutes = convertTimeToMinutes(bestFrequency || frequenceExistanteStr);
    const nbRamesOptimisee = frequenceOptimiseeMinutes !== 0 ? (5 / frequenceOptimiseeMinutes).toFixed(1) : "N/A"; // 00:05:00 = 5 minutes

        return {
            direction,
            trancheHoraire,
            tranchesOffre,
            chargeExistante: maxVoyageurs,
            frequenceExistante: frequenceExistanteStr,
            nbRamesExistante, // Ajouter le nombre de rames existantes
            diagnosticAvantOptimisation, // Ajouter le diagnostic avant optimisation
            frequenceOptimisee: bestFrequency || frequenceExistanteStr, // Utiliser la fréquence existante comme valeur par défaut
            nbRamesOptimisee, // Ajouter le nombre de rames optimisées
            chargeOptimisee: bestCharge !== null ? bestCharge.toFixed(0) : maxVoyageurs, // Utiliser la charge existante comme valeur par défaut
            diagnostic: diagnostic
        };
    }).filter(Boolean); // Supprimer les entrées null
}









            // Conversion du temps au format hh:mm:ss en minutes (pour simplifier les calculs)
            function convertTimeToMinutes(timeStr) {
                if (!timeStr) return null;
                const [hours, minutes, seconds] = timeStr.split(':').map(num => parseInt(num, 10));
                return hours * 60 + minutes + seconds / 60;
            }

            // Conversion de minutes en hh:mm:ss
            function convertMinutesToHHMMSS(minutes) {
                const totalSeconds = Math.floor(minutes * 60); // Convertit les minutes en secondes
                const hours = Math.floor(totalSeconds / 3600); // Heures
                const remainingSeconds = totalSeconds % 3600; // Secondes restantes après les heures
                const mins = Math.floor(remainingSeconds / 60); // Minutes restantes
                const secs = remainingSeconds % 60; // Secondes restantes

                return [
                    hours.toString().padStart(2, '0'), // Heures formatées
                    mins.toString().padStart(2, '0'), // Minutes formatées
                    secs.toString().padStart(2, '0')  // Secondes formatées
                ].join(':');
            }

            // Fonction pour peupler le tableau optimisé
            // Fonction pour peupler le tableau optimisé
function populateOptimizedTable(data) {
    const optimizedTableBody = document.getElementById('optimizedTable').querySelector("tbody");
    optimizedTableBody.innerHTML = "";

    data.forEach(item => {
        const row = optimizedTableBody.insertRow();

        // Colonne "Direction"
        const directionCell = row.insertCell(0);
        directionCell.innerText = item.direction === "Sens Aller" ? "sjg-->cvi(Aller)" : "cvi-->sjg(Retour)";

        // Colonne "Tranche Horaire"
        const trancheCell = row.insertCell(1);
        trancheCell.innerText = item.trancheHoraire;

        // Colonne "Tranches Offre"
        const offreCell = row.insertCell(2);
        offreCell.innerText = item.tranchesOffre;

        // Colonne "Charge Existante"
        const chargeExistanteCell = row.insertCell(3);
        chargeExistanteCell.innerText = item.chargeExistante;
        chargeExistanteCell.classList.add('charge-exist');

        // Colonne "Fréquence Existante"
        const freqExistanteCell = row.insertCell(4);
        freqExistanteCell.innerText = item.frequenceExistante;
        freqExistanteCell.classList.add('freq-exist');

        // Colonne "Nb Rames Existante"
        const nbRamesCell = row.insertCell(5);
        nbRamesCell.innerText = item.nbRamesExistante || "N/A";
        nbRamesCell.classList.add('nb-rames-exist');

        // Colonne "Diagnostic avant optimisation"
        const diagnosticAvantCell = row.insertCell(6);
        diagnosticAvantCell.innerText = item.diagnosticAvantOptimisation || "N/A";
        diagnosticAvantCell.classList.add('diagnostic-avant');

        // Colonne "Fréquence Optimisée"
        const freqOptiCell = row.insertCell(7);
        freqOptiCell.innerText = item.frequenceOptimisee !== null ? item.frequenceOptimisee : "null";
        freqOptiCell.classList.add('freq-opti');

        // Nouvelle colonne "Nb Rames Optimisée"
        const nbRamesOptiCell = row.insertCell(8);
        nbRamesOptiCell.innerText = item.nbRamesOptimisee || "N/A"; // Afficher "N/A" si la valeur est manquante
        nbRamesOptiCell.classList.add('nb-rames-opti');

        // Colonne "Charge Optimisée"
        const chargeOptimiseeCell = row.insertCell(9);
        chargeOptimiseeCell.innerText = item.chargeOptimisee;
        chargeOptimiseeCell.classList.add('charge-opti');

        // Colonne "Diagnostic après optimisation"
        const diagnosticCell = row.insertCell(10);
        diagnosticCell.innerText = item.diagnostic;
    });
}











            // Fonction pour obtenir le diagnostic
            function getDiagnosis(maxVoyageurs, time) {
    const peakCapacity = parseInt(document.getElementById('peakCapacity').value, 10);
    const offPeakCapacity = parseInt(document.getElementById('offPeakCapacity').value, 10);
    const coefHeures = parseInt(document.getElementById('coefHeures').value, 10) / 100; // Convertir en décimal
    const coefHeuresSup = parseInt(document.getElementById('coefHeuresSup').value, 10) / 100; // Convertir en décimal

    const timeRanges = {
    peak: [['07:00', '09:00'], ['12:00', '13:00'], ['16:00', '18:30']], // Ajout de 12h-13h
    offPeak: [['00:00', '07:00'], ['09:00', '12:00'], ['13:00', '16:00'], ['18:30', '23:59']]
};


    function isInRange(time, ranges) {
        for (let range of ranges) {
            if (time >= range[0] && time <= range[1]) {
                return true;
            }
        }
        return false;
    }

    // Déterminer si c'est une heure de pointe ou creuse
    const isPeak = isInRange(time, timeRanges.peak);

    // Calculer les bornes
    const seuilMax = isPeak ? peakCapacity : offPeakCapacity;
    const borneInf = coefHeures * seuilMax; // Borne inférieure
    const borneSup = (1 + coefHeuresSup) * seuilMax; // Borne supérieure




    // Déterminer le diagnostic
    if (maxVoyageurs >= borneInf && maxVoyageurs <= borneSup) {
        return 'OK'; // Charge dans l'intervalle acceptable
    } else if (maxVoyageurs < borneInf) {
        return 'Sur-offre'; // Charge en dessous de la borne inférieure
    } else {
        return 'Sous-offre'; // Charge au-dessus de la borne supérieure
    }
}




            // Fonction pour obtenir la classe CSS pour le diagnostic
            function getDiagnosticClass(diagnosis) {
    if (diagnosis === 'Sur-offre') return 'diagnostic-suroffre';
    if (diagnosis === 'Sous-offre') return 'diagnostic-sousoffre';
    if (diagnosis === 'OK') return 'diagnostic-ok';
    return '';
}


            // Fonction pour afficher les erreurs
            function displayErrorMessage(message) {
                const errorMessages = document.getElementById('errorMessages');
                errorMessages.innerHTML = `<li>${message}</li>`;
                hideResult();
            }

            // Fonctions pour gérer l'affichage des résultats
           // Fonctions pour gérer l'affichage des résultats
function showResult() {
    document.getElementById('result').classList.remove('hidden');
    document.getElementById('optimizedResult').classList.add('hidden');
}

function showOptimizedResult() {
    document.getElementById('optimizedResult').classList.remove('hidden');
    document.getElementById('result').classList.add('hidden');
}

function hideResult() {
    document.getElementById('result').classList.add('hidden');
    document.getElementById('optimizedResult').classList.add('hidden');
}


            // Fonction pour l'upload de fichier
            async function uploadFile(url, formData) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ! Statut : ${response.status}`);
                    }

                    return await response.json();
                } catch (error) {
                    throw error;
                }
            }

            // Fonction pour l'upload des fichiers
            async function uploadFiles(url, formData) {
                const peakCapacity = parseInt(document.getElementById('peakCapacity').value, 10);
                const offPeakCapacity = parseInt(document.getElementById('offPeakCapacity').value, 10);

                if (isNaN(peakCapacity) || isNaN(offPeakCapacity)) {
                    throw new Error("Veuillez saisir des capacités valides pour les heures de pointe et heures creuses !");
                }
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ! Statut : ${response.status}`);
                    }

                    return await response.json();
                } catch (error) {
                    throw error;
                }
            }
        });

        // Fonction pour exporter le tableau vers Excel
        function exportTableToExcel(tableId, filename = '') {
            const table = document.getElementById(tableId);
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.table_to_sheet(table);
            XLSX.utils.book_append_sheet(wb, ws, "Results");
            XLSX.writeFile(wb, filename + ".xlsx");
        }

        function filterTable(tableId, columnIndex) {
    const table = document.getElementById(tableId);
    const filter = table.querySelectorAll('thead th input')[columnIndex].value.toUpperCase();
    const rows = table.querySelectorAll('tbody tr');

    rows.forEach(row => {
        if (row.querySelector('td')) {
            const cell = row.querySelectorAll('td')[columnIndex];
            if (cell) {
                const text = cell.textContent.toUpperCase();
                row.style.display = text.includes(filter) ? '' : 'none';
            }
        }
    });
}


        function createOptimizationChart(data) {
    // Données pour le graphique
    const chartData = {
        labels: data.map(item => item.trancheHoraire), // Tranches horaires
        datasets: [
            {
                label: 'Charge Existante',
                data: data.map(item => item.chargeExistante), // Valeurs de la charge existante
                borderColor: 'rgba(75, 192, 192, 1)', // Couleur de la courbe
                fill: false,
            },
            {
                label: 'Charge Optimisée',
                data: data.map(item => item.chargeOptimisee), // Valeurs de la charge optimisée
                borderColor: 'rgba(255, 99, 132, 1)', // Couleur de la courbe
                fill: false,
            }
        ]
    };

    console.log("Données pour le graphique :", chartData); // Vérifiez les données dans la console

    // Créer ou mettre à jour le graphique
    const ctx = document.getElementById('optimizationChart').getContext('2d');
    if (window.optimizationChart) {
        // Si le graphique existe déjà, mettre à jour ses données
        window.optimizationChart.data = chartData;
        window.optimizationChart.update();
        console.log("Graphique mis à jour.");
    } else {
        // Sinon, créer un nouveau graphique
        window.optimizationChart = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Charge Existante vs Charge Optimisée'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Tranche Horaire'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Charge'
                        }
                    }
                }
            }
        });
        console.log("Nouveau graphique créé.");
    }
}

function convertDurationToMinutes(duration) {
    const [hours, minutes, seconds] = duration.split(':').map(Number);
    return hours * 60 + minutes + seconds / 60;
}





        function extractDataForChart() {
    const table = document.getElementById('optimizedTable');
    const rows = table.querySelectorAll('tbody tr');
    const data = [];

    // Récupérer la direction choisie
    const direction = document.getElementById('directionSelect').value;

    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 9) {
            const rowDirection = cells[0].textContent.trim();
            const trancheHoraire = cells[1].textContent.trim();
            const chargeExistante = parseFloat(cells[3].textContent.trim());
            const chargeOptimisee = parseFloat(cells[9].textContent.trim()); // Charge Optimisée à l'indice 9 maintenant
            const nbRamesExistante = parseFloat(cells[5].textContent.trim()) || 0; // Nb Rames Existante à l'indice 5
            const nbRamesOptimisee = parseFloat(cells[8].textContent.trim()) || 0; // Nb Rames Optimisée à l'indice 8

            if ((direction === "CVI_SJG" && rowDirection === "cvi-->sjg(Retour)") ||
                (direction === "SJG_CVI" && rowDirection === "sjg-->cvi(Aller)")) {
                data.push({
                    trancheHoraire,
                    chargeExistante,
                    chargeOptimisee,
                    nbRamesExistante,
                    nbRamesOptimisee
                });
            }
        }
    });

    return data;
}






        // Variables globales pour stocker les informations du filtre
let currentTableId = null;
let currentColumnIndex = null;

// Fonction pour gérer l'événement "Sélectionner tout"
function handleSelectAll(event) {
    const isChecked = event.target.checked;
    const filterOptions = document.querySelectorAll('.filterOption');
    filterOptions.forEach(option => {
        option.checked = isChecked;
    });
    console.log("Sélectionner tout :", isChecked); // Débogage
}

// Ouvrir la boîte modale de filtre
function openFilterModal(tableId, columnIndex) {
    currentTableId = tableId;
    currentColumnIndex = columnIndex;

    const table = document.getElementById(tableId);
    const rows = table.querySelectorAll('tbody tr');
    const uniqueValues = new Set();

    // Récupérer les valeurs uniques de la colonne (uniquement pour les lignes visibles)
    rows.forEach(row => {
        if (row.style.display !== 'none') { // Ignorer les lignes déjà filtrées
            const cell = row.querySelectorAll('td')[columnIndex];
            if (cell) {
                uniqueValues.add(cell.textContent.trim());
            }
        }
    });

    // Vider la boîte modale avant d'ajouter de nouvelles options
    const filterOptions = document.getElementById('filterOptions');
    filterOptions.innerHTML = ''; // Vider le contenu

    // Supprimer l'élément "Sélectionner tout" s'il existe déjà
    const existingSelectAll = document.getElementById('selectAll');
    if (existingSelectAll) {
        existingSelectAll.remove();
    }

    // Ajouter l'option "Sélectionner tout"
    const selectAllLabel = document.createElement('label');
    selectAllLabel.style.display = 'block';
    selectAllLabel.innerHTML = `
        <input type="checkbox" id="selectAll" checked> Sélectionner tout
    `;
    filterOptions.appendChild(selectAllLabel);

    // Ajouter les valeurs uniques
    uniqueValues.forEach(value => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.innerHTML = `
            <input type="checkbox" class="filterOption" value="${value}" checked> ${value}
        `;
        filterOptions.appendChild(label);
    });

    // Gérer l'événement "Sélectionner tout"
    const selectAllCheckbox = document.getElementById('selectAll');
    selectAllCheckbox.addEventListener('change', handleSelectAll);

    // Afficher la boîte modale
    document.getElementById('filterModal').style.display = 'block';
}







// Appliquer le filtre
function applyFilter() {
    const table = document.getElementById(currentTableId);
    const rows = table.querySelectorAll('tbody tr');
    const selectedValues = [];

    // Récupérer les valeurs sélectionnées
    document.querySelectorAll('#filterOptions input:checked').forEach(input => {
        if (input.value !== "on") { // Ignorer l'option "Sélectionner tout"
            selectedValues.push(input.value);
        }
    });

    // Filtrer les lignes
    rows.forEach(row => {
        const cell = row.querySelectorAll('td')[currentColumnIndex];
        if (cell) {
            const cellValue = cell.textContent.trim();
            // Appliquer le filtre uniquement si la ligne est déjà visible
            if (row.style.display !== 'none') {
                row.style.display = selectedValues.includes(cellValue) ? '' : 'none';
            }
        }
    });

    // Fermer la boîte modale
    closeFilterModal();
}

function filterTable(tableId, columnIndex) {
    const table = document.getElementById(tableId);
    const filter = table.querySelectorAll('thead th input')[columnIndex].value.toUpperCase();
    const rows = table.querySelectorAll('tbody tr');

    rows.forEach(row => {
        if (row.querySelector('td')) {
            const cell = row.querySelectorAll('td')[columnIndex];
            if (cell) {
                const text = cell.textContent.toUpperCase();
                // Appliquer le filtre uniquement si la ligne est déjà visible
                if (row.style.display !== 'none') {
                    row.style.display = text.includes(filter) ? '' : 'none';
                }
            }
        }
    });
}




// Fermer la boîte modale de filtre
function closeFilterModal() {
    document.getElementById('filterModal').style.display = 'none';
}

// Ajouter des boutons de filtre aux en-têtes de colonne
function addFilterButtons(tableId) {
    const table = document.getElementById(tableId);
    const headerRow = table.querySelector('thead tr');

    Array.from(headerRow.querySelectorAll('th')).forEach((th, index) => {
        const filterButton = document.createElement('button');
        filterButton.textContent = 'Filtrer';
        filterButton.style.marginLeft = '10px';
        filterButton.onclick = () => openFilterModal(tableId, index);
        th.appendChild(filterButton);
    });
}

// Appliquer les boutons de filtre aux tables
document.addEventListener('DOMContentLoaded', () => {
    addFilterButtons('diagnosticTable');
    addFilterButtons('optimizedTable');
});

// Gérer les clics sur les boutons OK et Annuler
document.getElementById('applyFilterButton').addEventListener('click', applyFilter);
document.getElementById('cancelFilterButton').addEventListener('click', closeFilterModal);

       function resetFilters(tableId) {
    const table = document.getElementById(tableId);
    const rows = table.querySelectorAll('tbody tr');

    rows.forEach(row => {
        row.style.display = ''; // Afficher toutes les lignes
    });

    // Réinitialiser les champs de filtre
    const filterInputs = table.querySelectorAll('thead th input');
    filterInputs.forEach(input => {
        input.value = '';
    });
}
function exportTableToPDF(tableId, filename = '') {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'pt', 'a4');
    const table = document.getElementById(tableId);

    // Créer un indicateur de chargement
    const loadingIndicator = document.createElement('div');
    loadingIndicator.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
        ">
            Génération du PDF en cours... Veuillez patienter.
        </div>
    `;
    document.body.appendChild(loadingIndicator);

    // Cloner le tableau pour le traitement
    const tableClone = table.cloneNode(true);

    // Appliquer des styles optimisés pour l'export
    tableClone.style.width = '100%';
    tableClone.style.position = 'absolute';
    tableClone.style.left = '-9999px';
    tableClone.style.top = '0';
    tableClone.style.visibility = 'visible';

    // Ajuster les styles pour l'export
    const cells = tableClone.querySelectorAll('th, td');
    cells.forEach(cell => {
        cell.style.padding = '5px';
        cell.style.fontSize = '10px';
    });

    document.body.appendChild(tableClone);

    // Options pour html2canvas
    const options = {
        scale: 2,
        scrollX: 0,
        scrollY: 0,
        windowWidth: tableClone.scrollWidth,
        windowHeight: tableClone.scrollHeight,
        useCORS: true,
        allowTaint: true,
        logging: true
    };

    html2canvas(tableClone, options).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const imgWidth = doc.internal.pageSize.getWidth() - 20;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;

        // Calculer le nombre de pages nécessaires
        const pageHeight = doc.internal.pageSize.getHeight() - 20;
        let heightLeft = imgHeight;
        let position = 10;
        let pageNumber = 1;

        // Première page
        doc.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
        heightLeft -= pageHeight;

        // Pages supplémentaires si nécessaire
        while (heightLeft >= 0) {
            doc.addPage();
            position = heightLeft - imgHeight;
            doc.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
            heightLeft -= pageHeight;
            pageNumber++;
        }

        // Enregistrer le PDF
        doc.save(filename + '.pdf');

        // Nettoyer
        document.body.removeChild(tableClone);
        document.body.removeChild(loadingIndicator);
    }).catch(error => {
        console.error("Erreur:", error);
        alert("Erreur lors de la génération du PDF: " + error.message);
        document.body.removeChild(tableClone);
        document.body.removeChild(loadingIndicator);
    });
}


    </script>



</body>
</html>